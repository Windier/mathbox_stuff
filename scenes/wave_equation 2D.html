<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>2D Wave Equation</title>
  <script src="../../build/mathbox-bundle.js"></script>
  <script src="../../build/dat.gui.min.js"></script>
  <link rel="stylesheet" href="../../build/mathbox.css">
  <meta name="viewport" content="initial-scale=1, maximum-scale=1">
</head>
<body>

  <script type="application/glsl" id="vertex-xyz">
  // Enable STPQ mapping
  #define POSITION_STPQ
  void getVertex(inout vec4 xyzw, inout vec4 stpq) {
    // Store XYZ per vertex in STPQ
    stpq = xyzw;
  }
  </script>

  <script type="application/glsl" id="fragment-xyz">
  // Enable STPQ mapping
  #define POSITION_STPQ

  // thanks to http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl 
  vec3 hsv2rgb(vec3 c)
  {
      vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
      vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
      return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
  }

  vec4 getColor(vec4 rgba, inout vec4 stpq) {
    // Retrieve interpolated XYZ from vertices and use as RGB color.
    vec3 rgb = hsv2rgb(0.32 + vec3(-clamp(0.6*stpq.z/2.0,-0.27,0.27),1.0,1.0));
    
    return vec4(rgb, 1.0);
  }
  </script>
  <script>

    var cos = function(x){
      return Math.cos(x)
    }
    var sin = function(x){
      return Math.sin(x)
    }
    var pow = function(x,y){
      return Math.pow(x,y)
    };
    var exp = function(x){
      return Math.exp(x)
    };
  
    mathbox = mathBox({
      plugins: ['core', 'controls', 'cursor', 'stats'],
      controls: {
        klass: THREE.OrbitControls
      },
    });
    three = mathbox.three;

    three.camera.position.set(1, 1, 3);
    three.renderer.setClearColor(new THREE.Color(0xFFFFFF), 1.0);

    var δ = 5; // range

    view = mathbox
    .set({
      focus: 3,
    })
    .cartesian({
      range: [[-δ, δ], [-δ, δ], [-δ, δ]],
      scale: [1, 1, 1],
      rotation:[-π/2, 0, -π/2]
    })

    view.grid({
      divideX: 10,
      divideY:10,
      width: 1,
      opacity: 0.2,
      zBias: -5,
    });

   	var size = 64;
    var c = 3.0; //  wave speed
   	var δt = 0.0166; // time step
    var δs = 2*δ/(size); // spatial step
    var r = c*δt/δs;

    var u_0 = [];
    var u_1 = [];
    var u = [];

    for (var i = 0; i < size+1; i++) {
      u[i] = []; u_0[i] = []; u_1[i] = [];
      for (var j = 0; j < size+1; j++) {

      	x = i*δs - δ; y = j*δs - δ;
        // Initial condition
        u_x = 3*exp(-pow(-x,2)-pow(-y,2));
        u_0[i][j] = u_x;
        u_1[i][j] = u_x;
        u[i][j] = u_x;

      }
    };

    view.array({
    	expr:function(emit){

        // membrane
        for (var i = 1; i < size; i++) {
          for (var j = 1; j < size; j++) {

            x = i*δs - δ; y = j*δs - δ
            // wave equation in 2D
            u[i][j] = 2.*(1 - 2.*pow(r,2))*u_1[i][j] - u_0[i][j] + pow(r,2)*(u_1[i+1][j] + u_1[i-1][j] + u_1[i][j+1] + u_1[i][j-1]);

            emit(x, y, u[i][j]);
          }
        };

        // update the last 2 states
        for (var i = 1; i < size; i++){
            u_0[i] = u_1[i].slice();
            u_1[i] = u[i].slice();
        };

    	},
    	items: (size-1)*(size-1),
    	channels: 3,
    })

    view.shader({
        code: "#vertex-xyz"
      })
      .vertex({
        pass: 'data'
      })
      .shader({
        code: "#fragment-xyz"
      })
      .fragment({
        gamma: true
      })
      .point({
      size: 2.5,
    })

  </script>
</body>
</html>
